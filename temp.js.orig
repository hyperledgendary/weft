#!/usr/bin/env node
/*
 * SPDX-License-Identifier: Apache-2.0
 */

'use strict';
const fs = require('fs');
const { Gateway, Wallets } = require('fabric-network');
const path = require('path');
const sanitize = require("sanitize-filename");
const mkdirp = require('mkdirp')
const rimraf = require("rimraf");
const FabricCAServices = require('fabric-ca-client');

const argv = require('yargs').
    command({
        command: 'import',
        desc: 'Imports an infrastruture identity to an application wallet',
        builder: (yargs) => {
            return yargs.options({
                'jsonid': { 'alias': 'i', describe: 'Path to infrastructure identity', demandOption: true },
                'wallet': { 'alias': 'w', describe: 'Path to application wallet', demandOption: true },
            })
        }
    })
    .command({
        command: 'new',
        desc: 'Creates new identity and adds to an application wallet',
        builder: (yargs) => {
            return yargs.options({
                'profile': { 'alias': 'p', describe: 'Path to the connection profile JSON', demandOption: true },
                'wallet': { 'alias': 'w', describe: 'Path to application wallet', demandOption: true },
                'name': { alias: 'n', describe: 'Name of the new user', demandOption: true },
                'admin': { alias: 'a', describne: 'admin id to use', default: 'admin' }
            })
        }
    })
    .command({
        command: 'enroll',
        desc: 'Creates new identity and adds to an application wallet',
        builder: (yargs) => {
            return yargs.options({
                'profile': { 'alias': 'p', describe: 'Path to the connection profile JSON', demandOption: true },
                'wallet': { 'alias': 'w', describe: 'Path to application wallet', demandOption: true },
                'name': { alias: 'n', describe: 'Name of the new user for the app wallet', demandOption: true },
                'enrollid': { alias: 'e', describe: 'EnrollID', demandOption: true },
                'enrollpwd': { alias: 's', describe: 'Enroll password', demandOption: true }
            })
        }
    })
    .command(
        "resources", "Generate resources for cli & applications", (yargs) => {
            return yargs.options({
                'resource-dir': { 'alias': 'd', describe: 'Directory to put all the resources', demandOption: true, default: "_cfg" },
                'gateway': { 'alias': 'p', describe: 'Relative path for gateways connection profile JSON', demandOption: false, default: 'app/gateway' },
                'wallet': { 'alias': 'w', describe: 'Relative path for the application wallets', demandOption: false, default: 'app/wallet' },
                'crypto': { 'alias': 'm', describe: 'Relative path for the crypto configuration', demandOption: false, default: 'cli/crypto' },
                'env': { 'alias': 'e', describe: 'Relative path for the env var scripts', demandOption: false, default: 'cli/envvar' },
                'org': { 'alias': 'o', describe: 'Name of the organization', demandOption: true },
                'user': { 'alias': 'u', describe: 'Name of the user', demandOption: true }
            }).command(
                {
                    command: 'microfab',
                    desc: 'Calls the MicroFab REST api and create the Wallets and Gateways for applications',
                    builder: (yargs) => {
                        return yargs.options({
                            'config': { alias: 'c', describe: 'JSON Configuration file, if not supplied defaults to stdin', type: 'string', demandOption: false }
                        }
                        )
                    }
                }).command(
                    {
                        command: 'ansible',
                        desc: 'Given ansible output dir create the Wallets and Gateways for applications',
                        builder: (yargs) => {
                            return yargs.options({
                                'ansibledir': { alias: 'a', describe: 'directory of the ansible config', type: 'string', demandOption: false }
                            }
                            )
                        }
                    })
        })



const getDirectories = source =>
    fs.readdirSync(source, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name)

const getJSONFiles = source =>
    fs.readdirSync(source, { withFileTypes: true })
        .filter(dirent => dirent.isFile() && dirent.name.endsWith('json'))
        .map(dirent => dirent.name)


async function enroll(argv) {
    // Create a new file system based wallet for managing identities.
    const walletPath = path.resolve(argv.wallet);
    const wallet = await Wallets.newFileSystemWallet(walletPath);

    console.log(`Using wallet path : ${walletPath}`)
    console.log(`Using gateway path : ${argv.profile}`)


    // get the gateway profile
    let profile = getProfile(argv.profile);
    let orgName = profile.client.organization;
    console.log(`Using the organization : ${orgName}`)

    let orgmspid = profile.organizations[orgName].mspid;

    // Create a new CA client for interacting with the CA.
    let cas = profile.organizations[orgName].certificateAuthorities;

    let caname;
    if (cas.length === 0) {
        throw new Error("No CAs listed in gateway");
    } else if (cas.length === 1) {
        caname = cas[0];
    }
    const caInfo = profile.certificateAuthorities[caname];

    const caTLSCACerts = caInfo.tlsCACerts.pem;
    const ca = new FabricCAServices(caInfo.url, { trustedRoots: caTLSCACerts, verify: false }, caInfo.caName);

    const userExists = await wallet.get(argv.name);
    if (userExists) {
        console.log(`An identity for the client user ${argv.name} already exists in the wallet`);
        return;
    }


    // Enroll the admin user, and import the new identity into the wallet.
    const enrollment = await ca.enroll({ enrollmentID: argv.enrollid, enrollmentSecret: argv.enrollpwd });
    const x509Identity = {
        credentials: {
            certificate: enrollment.certificate,
            privateKey: enrollment.key.toBytes(),
        },
        mspId: orgmspid,
        type: 'X.509',
    };
    await wallet.put(argv.name, x509Identity);

}

const JSON_EXT = /json/gi;
const YAML_EXT = /ya?ml/gi;

function getProfile(profilename) {

    const ccpPath = path.resolve(profilename);
    if (!fs.existsSync(ccpPath)) {
        throw new Error(`Gateway ${ccpPath} does not exist`);
    }

    let type = path.extname(ccpPath);

    if (JSON_EXT.exec(type)) {
        return JSON.parse(fs.readFileSync(ccpPath));
    } else if (YAML_EXT.exec(type)) {
        return yaml.safeLoad(fs.readFileSync(ccpPath));
    } else {
        throw new Error(`Extension of ${ccpPath} not recognised`)
    }
}

async function importToWallet(argv) {

    // Create a new file system based wallet for managing identities.
    const walletPath = path.resolve(argv.wallet);
    const wallet = await Wallets.newFileSystemWallet(walletPath);

    let jsonIdentity = argv.jsonIdentity
    // load the JSON identity
    if (!jsonIdentity) {
        jsonIdentity = JSON.parse(fs.readFileSync(path.resolve(argv.jsonid)));
    }

    // Check to see if we've already got the user.
    const userIdentity = await wallet.get(jsonIdentity.name);
    if (userIdentity) {
        console.log(`An identity for the user "${jsonIdentity.name}" already exists in the wallet`);
        return;
    }

    const certificate = Buffer.from(jsonIdentity.cert, 'base64').toString();
    const privateKey = Buffer.from(jsonIdentity.private_key, 'base64').toString();
    const identity = {
        credentials: {
            certificate,
            privateKey
        },
        mspId: jsonIdentity.msp_id,
        type: 'X.509'
    }

    await wallet.put(jsonIdentity.name, identity);

    console.log(`Added identity under label ${jsonIdentity.name} to the wallet at ${walletPath}`);
}

async function createNewUser() {
    try {
        const ccpPath = path.resolve(argv.profile);
        // Create a new file system based wallet for managing identities.
        const walletPath = path.resolve(argv.wallet);
        const wallet = await Wallets.newFileSystemWallet(walletPath);
        console.log(`Wallet path: ${walletPath}`);

        let newUserId = argv.name;

        // Check to see if we've already enrolled the user.
        const userIdentity = await wallet.get(newUserId);
        if (userIdentity) {
            console.log(`An identity for the user "${newUserId}" already exists in the wallet`);
            return;
        }

        // Check to see if we've already enrolled the admin user.
        const adminIdentity = await wallet.get(argv.admin);
        if (!adminIdentity) {
            console.log(`An identity for the admin user "${argv.admin}" does not exist in the wallet`);
            return;
        }



        // Create a new gateway for connecting to our peer node.
        const gateway = new Gateway();
        await gateway.connect(ccpPath, { wallet, identity: argv.admin, discovery: { enabled: true, asLocalhost: true } });

        // Get the CA client object from the gateway for interacting with the CA.
        const client = gateway.getClient();
        const ca = client.getCertificateAuthority();
        const adminUser = await client.getUserContext(argv.admin, false);

        // Register the user, enroll the user, and import the new identity into the wallet.
        const secret = await ca.register({ affiliation: 'org1.department1', enrollmentID: newUserId, role: 'client' }, adminUser);
        const enrollment = await ca.enroll({ enrollmentID: newUserId, enrollmentSecret: secret });
        const x509Identity = {
            credentials: {
                certificate: enrollment.certificate,
                privateKey: enrollment.key.toBytes(),
            },
            mspId: adminIdentity.mspId,
            type: 'X.509',
        };
        await wallet.put(newUserId, x509Identity);
        console.log(`Successfully registered and enrolled admin user "${newUserId}" and imported it into the wallet`);

    } catch (error) {
        console.error(`Failed to register user "${newUserId}": ${error}`);
        process.exit(1);
    }
}

async function resources(argv) {
    let resourceTargets = { 'ansible': ansible_resources, 'microfab': macrofab_resources };
    console.log(resourceTargets[argv._[1]]);
    await resourceTargets[argv._[1]](argv);
}

async function ansible_resources(argv) {
    console.log(`Making from Ansible`);
    console.log(argv)

    let ansiblePath = path.resolve(argv['ansibledir']);
    if (!fs.existsSync(ansiblePath)) {
        throw new Error('Can not locate ansible directory ' + ansiblePath);
    }

    // Copy across the gateway connection profiles
    console.log(`Copying connection profile...`)

    // for each org copy across the profiles.
    let orgs = getDirectories(path.join(ansiblePath, 'gateways'));
    orgs.forEach(d => {
        let gatewayfilename = `${argv.org.toLowerCase()}_gateway.json`;

        let srcPath = path.join(ansiblePath, 'gateways', d, gatewayfilename);
        console.log(srcPath)
        if (fs.existsSync(srcPath)) {
            fs.copyFileSync(srcPath,
                path.join(argv.gatewaypath, gatewayfilename));
        }
    })

    console.log(`...done`)

    // now need the identity
    let ids = getDirectories(path.join(ansiblePath, 'wallets'));
    orgs.forEach(d => {
        let walletsdir = path.join(ansiblePath, 'wallets', d);
        let ids = getJSONFiles(walletsdir);
        ids.forEach(id => {
            let userIdentityFile = path.join(walletsdir, id, `${argv.user}.json`);
            let jsonIdentity = JSON.parse(fs.readFileSync(userIdentityFile));
            let fullWalletPath = path.resolve(argv.walletpath, sanitize(argv.user));
            mkdirp.sync(fullWalletPath);
            // await importToWallet({ wallet: fullWalletPath, jsonIdentity });
        })

    })



    // now need the msp directory stuff.
    let cryptoroot = path.resolve(argv.mspcrypto, sanitize(argv.org), sanitize(argv.user));
    mkdirp.sync(cryptoroot);

    // now for the msp stuff

    mkdirp.sync(path.join(cryptoroot, 'cacerts'));
    mkdirp.sync(path.join(cryptoroot, 'keystore'));
    mkdirp.sync(path.join(cryptoroot, 'signcerts'));
    mkdirp.sync(path.join(cryptoroot, 'admincerts'));

    let privateKey = Buffer.from(jsonIdentity.private_key, 'base64').toString();
    let pemfile = Buffer.from(jsonIdentity.cert, 'base64').toString();
    fs.writeFileSync(path.join(cryptoroot, 'signcerts', `cert.pem`), pemfile)
    fs.writeFileSync(path.join(cryptoroot, 'keystore', `cert_sk`), privateKey)

    let cacert = JSON.parse(fs.readFileSync(path.join(ansiblePath, 'gateways', argv.org, `${argv.org.toLowerCase()}_gateway.json`))).certificateAuthorities.AmpretiaCA.tlsCACerts.pem;
    fs.writeFileSync(path.join(cryptoroot, 'cacerts', 'cert.pem'), cacert);

    let adminCert = JSON.parse(fs.readFileSync(path.join(ansiblePath, 'wallets', argv.org, `admin.json`))).cert;
    fs.writeFileSync(path.join(cryptoroot, 'admincerts', `cert.pem`), Buffer.from(adminCert, 'base64').toString())

    // copy the tls
    let cryptodir = path.resolve(argv.mspcrypto);

    mkdirp.sync(path.join(cryptodir, 'Orderer'));

    fs.copyFileSync(path.join(ansiblePath, 'wallets', 'Orderer', 'ca-tls-root.pem'),
        path.join(cryptodir, 'Orderer', 'ca-tls-root.pem'));
    fs.copyFileSync(path.join(ansiblePath, 'wallets', argv.org, 'tls-root.pem'),
        path.join(cryptodir, argv.org, 'tls-root.pem'));

    mkdirp.sync(path.join(cryptodir, argv.org, 'ampretiapeer1tls'));
    fs.copyFileSync(path.join(ansiblePath, 'wallets', argv.org, 'ampretiapeer1tls', 'ca.crt'),
        path.join(cryptodir, argv.org, 'ampretiapeer1tls', 'ca.crt'));

    await writeEnvVar(argv);
}

async function macrofab_resources(argv) {
    let config;

    // JSON configuration either from stdin or filename
    if (!argv.config) {
        config = JSON.parse(fs.readFileSync(0));
    } else {
        let fabletConfig = path.resolve(argv.config);
        if (!fs.existsSync(fabletConfig)) {
            throw new Error(`Fablet config json not found at ${fabletConfig}`)
        }
        config = JSON.parse(fs.readFileSync(fabletConfig));
    }

    // locate the gateways in the, and create the connection profile
    config.filter(c => c.type === "gateway").forEach(gateway => {
        let profilePath = path.resolve(argv.gatewaypath, `${sanitize(gateway.id)}.json`);
        fs.writeFileSync(profilePath, JSON.stringify(gateway));
    })

    // locate the identities
    config.filter(c => c.type === "identity").forEach(async (id) => {

        let fullWalletPath = path.resolve(argv.walletpath, sanitize(id.wallet));
        mkdirp.sync(fullWalletPath);
        id.name = id.id;
        // use import to wallet function
        await importToWallet({ wallet: fullWalletPath, jsonIdentity: id });

        // create the msp cryto dir structure for the peer commands
        let cryptoroot = path.resolve(argv.cryptopath, sanitize(id.wallet), sanitize(id.id));
        // now for the msp stuff
        mkdirp.sync(path.join(cryptoroot, 'msp'));
        mkdirp.sync(path.join(cryptoroot, 'msp', 'cacerts'));
        mkdirp.sync(path.join(cryptoroot, 'msp', 'keystore'));
        mkdirp.sync(path.join(cryptoroot, 'msp', 'signcerts'));

        let privateKey = Buffer.from(id.private_key, 'base64').toString();
        let pemfile = Buffer.from(id.cert, 'base64').toString();
        fs.writeFileSync(path.join(cryptoroot, 'msp', 'signcerts', `${id.id}.pem`), pemfile)
        fs.writeFileSync(path.join(cryptoroot, 'msp', 'keystore', `cert_sk`), privateKey)
    })

    await writeEnvVar(argv);
}

async function writeEnvVar(peerAddress:string ) {
    let envpath = path.resolve(argv.envvarpath);
    mkdirp.sync(envpath);
    let repo_root = path.resolve(argv.cryptopath);

    let cmds = `

# Address of the peer being targetted
export CORE_PEER_ADDRESS=${peerAddress}"

# Identifity of the Organization
export CORE_PEER_LOCALMSPID="${org}"

# Location of the wallet for the user to be used
export CORE_PEER_MSPCONFIGPATH="${repo_root}/${org}/${user}"

# If tls is enabled for the network communcations, and note the root certificate, and the Orderer's TLS cert
export CORE_PEER_TLS_ENABLED="true"
export CORE_PEER_TLS_ROOTCERT_FILE="${repo_root}/${argv.org}/tls-root.pem"
export ORDERER_TLS_CERT=${repo_root}/Orderer/ca-tls-root.pem

# Will need the TLS for each Peer
export AMPRETIA_PEER_TLS=${repo_root}/${argv.org}/ampretiapeer1tls/ca.crt

# Need the configuration directory, though no clear what is actually needed from it 
export FABRIC_CFG_PATH=/usr/local/config/
`;

    fs.writeFileSync(path.join(envpath, 'envvar.sh'), cmds);

}

// The output directory and subdirectories. 
if (argv["resource-dir"]) {
    argv.resourcepath = path.resolve(argv["resource-dir"]);
    argv.gatewaypath = path.resolve(argv["resource-dir"], argv.gateway);
    argv.walletpath = path.resolve(argv["resource-dir"], argv.wallet);
    argv.cryptopath = path.resolve(argv["resource-dir"], argv.crypto);
    argv.envvarpath = path.resolve(argv["resource-dir"], argv.env);

    // create if needed, otherwise clear
    // TODO: make this a force option
    if (!fs.existsSync(argv.resourcepath)) {
        mkdirp.sync(argv.resourcepath);
    } else {
        rimraf.sync(argv.resourcepath);
    }

    // make the sub-directories
    mkdirp.sync(argv.gatewaypath);
    mkdirp.sync(argv.walletpath);
    mkdirp.sync(argv.cryptopath);
    mkdirp.sync(argv.envvarpath);
}


console.log(argv);


const cmds = { import: importToWallet, new: createNewUser, resources: resources, enroll: enroll };
cmds[argv._[0]](argv);
